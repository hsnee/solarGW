#-----------------------# Import needed modules#-----------------------from __future__ import divisionimport numpy as npimport pylab as pltimport gwpyimport h5pyimport lalfrom astropy.coordinates import get_sunimport astropy.time as Timeimport astropyfrom gwpy.timeseries import TimeSeriesfrom scipy.signal import butterfrom scipy.signal import filtfilt#---------------# Open the File#---------------#fileNameH = 'H-H1_LOSC_4_V1-967966720-4096.hdf5'#dataFileH = h5py.File(fileNameH, 'r')# For loop to read multiple files later on# includes everything to line 49# Read segment instead using gwpy, where starttime and endtime are from the dag filepathtoinput = "/home/husni.almoubayyed/"strainH = TimeSeries.read('S6framesH1.lcf',channel='H1:LDAS-STRAIN', start=starttime, end=endtime)strainL = TimeSeries.read('S6framesL1.lcf',channel='L1:LDAS-STRAIN', start=starttime, end=endtime)#-------------------# Explore the file#-------------------#for key in dataFileH.keys():#    print key#---------------------# Read in strain data#---------------------# strainH = dataFileH['strain']['Strain'].value# tsH = dataFileH['strain']['Strain'].attrs['Xspacing'] replace this withtsH = 2.44140625E-4tsL = 2.44140625E-4#-----------------------# Read in some meta data#-----------------------# metaKeysH = dataFileH['meta'].keys()# metaH = dataFileH['meta']#print("\n\n")#for key in metaKeysH:#    print(key, metaH[key].value)# gpsStartH = metaH['GPSstart'].value# durationH = metaH['Duration'].value# gpsEndH   = gpsStartH + durationH# detectorH = metaH['Detector']# dataFileH.close()gpsStartH = starttimedurationH = endtime - starttimegpsEndH = endtime#--------------------------## Redo this for L detector ##--------------------------## fileNameL = 'L-L1_LOSC_4_V1-967966720-4096.hdf5'# dataFileL = h5py.File(fileNameL, 'r')# strainL = dataFileL['strain']['Strain'].value# tsL = dataFileL['strain']['Strain'].attrs['Xspacing']# metaKeysL = dataFileL['meta'].keys()# metaL = dataFileL['meta']# gpsStartL = metaL['GPSstart'].value# durationL = metaL['Duration'].value# gpsEndL   = gpsStartL + durationL# detectorL = metaL['Detector']# dataFileL.close()gpsStartL = gpsStartHdurationL = durationHgpsEndL = gpsEndHture##############################---------------------------# Applying a bandpass filter#---------------------------# strainL = TimeSeries(strainL)# strainH = TimeSeries(strainH)ord = 4Wn = [100.0/2918.0,300.0/2918.0]type = 'bandpass'bL,aL = butter(ord,Wn, btype=type)bH,aH = butter(ord,Wn, btype=type)strainL = filtfilt(bL,aL,strainL)strainH = filtfilt(bH,aH,strainH)#---------------------------# Create a time vector#---------------------------timeH = np.arange(gpsStartH, gpsEndH, tsH)timeL = np.arange(gpsStartL, gpsEndL, tsL)#-----------------------------------------------# Create mapping between detector name and index#-----------------------------------------------detMap = {'H1': lal.LALDetectorIndexLHODIFF, 'L1':lal.LALDetectorIndexLLODIFF}#-------------------------------------# Get detector structure for H1 and L1#-------------------------------------detH1 = lal.CachedDetectors[detMap['H1']]detL1 = lal.CachedDetectors[detMap['L1']]#--------------------------------------------------------------# Set a GPS time (this is just a random value for this example)#--------------------------------------------------------------tgps = lal.LIGOTimeGPS(gpsStartH, 0)#---------------------------------------------------------# Get right ascension and declination of source in radians#---------------------------------------------------------ra  = coords.ra.hour  * np.pi/12dec = coords.dec.hour * np.pi/12# do this at every 30 secondsnumseg30 = int((endtime-starttime)/30.)seg30 = gpsStartH + numseg30*30.tdelay = [[0] for _ in range(numseg30-1)]for i in range(numseg30-1):	if (timeH>seg30[i]&timeH<seg30[i+1]):		coordstime=seg30[i]		coords = get_sun(Time.Time(coordstime,format='gps'))		tdelay[i] = lal.ArrivalTimeDiff(detH1.location, detL1.location, coords.ra.hour*np.pi/12, coords.dec.hour*np.pi/12, tgps)	else:		pass#----------------------# Plot the time series#----------------------# numSamples = 10000# plt.plot(timeL[0:numSamples]-tdelay, strainL[0:numSamples],label='L1 data')# plt.plot(timeH[0:numSamples], strainH[0:numSamples], label='H1 data')# plt.xlabel('GPS Time (s)')# plt.ylabel('Strain')# plt.title('Strain data on 2010-09-08')# plt.legend(fancybox=True)# plt.show()#---------------# Get Background#---------------background_intervals = np.linspace(1,120,120)*600ra_background, background_tdelay, dec_background, coords_background = [[[0] for _ in range(120)] for _ in range(4)]background_intervals = background_intervals.astype(int)for j in range(len(background_intervals)):	coords_background[j]=get_sun(Time.Time(gpsStartH-background_intervals[j],format='gps'))	ra_background[j]  = coords_background[j].ra.hour  * np.pi/12	dec_background[j] = coords_background[j].dec.hour * np.pi/12	background_tdelay[j] = lal.ArrivalTimeDiff(detH1.location, detL1.location, ra_background[j], dec_background[j], tgps)#----------------------# Plot the background#----------------------# numSamples = 10000# plt.plot(timeL[0:numSamples]-background_tdelay[1], strainL[0:numSamples],label='L1 data')# plt.plot(timeH[0:numSamples], strainH[0:numSamples], label='H1 data')# plt.xlabel('GPS Time (s)')# plt.ylabel('Strain')# plt.title('Strain data on 2010-09-08')# plt.legend(fancybox=True)# plt.show()#-------------------------------------------------------# When running the jobs, create files instead of plots#-------------------------------------------------------